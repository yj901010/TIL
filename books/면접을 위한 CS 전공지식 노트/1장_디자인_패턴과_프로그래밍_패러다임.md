# 1장 디자인 패턴과 프로그래밍 패러다임

## 디자인패턴
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약'형태로 만들어 놓은 것을 의미한다.

## 싱글톤패턴
<img src="images/singleton.png" alt="Singleton Pattern" width="300"/><br>
하나의 클래스에 **오직 하나의 인스턴스**만 가지는 패턴이다.<br>
보통 **데이터베이스 연결 모듈**에 많이 사용된다.<br>
**장점**: 하나의 인스턴스를 다른 모듈이 공유하여 사용하여 인스턴스 생성 비용이 줄어든다.<br>
**단점**: 의존성이 높아진다.<br>

### 싱글톤 패턴 수동 구현 방식
- 초기화 타이밍 제어나 복잡한 로직을 사용해야할 때 가능
```java
// 싱글톤 클래스 정의
class Singleton {

    // 정적 내부 클래스. Singleton 인스턴스를 보관하는 역할만 함.
    private static class SingleInstanceHolder {
        // 클래스 로딩 시 단 한 번만 초기화됨 (JVM이 보장함)
        private static final Singleton INSTANCE = new Singleton();
    }

    // 외부에서는 이 메서드로만 인스턴스를 얻을 수 있음
    public static Singleton getInstance() {
        // getInstance()가 호출될 때, 내부 클래스가 로딩되며 INSTANCE가 생성됨
        return SingleInstanceHolder.INSTANCE;
    }

    // 생성자는 외부에서 호출할 수 없도록 private 지정
    private Singleton() {
        // 생성자에 어떤 초기화 로직이 있어도 외부에서 new로 생성 못함
    }
}
```

```java
// 싱글톤 테스트용 클래스
public class HelloWorld {
    public static void main(String[] args) {
        // Singleton 인스턴스를 두 번 호출
        Singleton a = Singleton.getInstance();
        Singleton b = Singleton.getInstance();

        // 두 인스턴스의 주소를 확인 (hashCode가 같으면 같은 객체)
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());

        // 같은 인스턴스인지 비교 (싱글톤이면 항상 true여야 함)
        if (a == b) {
            System.out.println(true); // true 출력됨
        }
    }
}
```

### Enum 방식
- 가장 간단하고 안전하게 구현 가능
```java
// enum을 이용한 싱글톤 정의
public enum Singleton {
    // 단 하나의 인스턴스를 정의
    INSTANCE;

    // 싱글톤 인스턴스가 호출할 수 있는 일반 메서드
    public void someMethod() {
        System.out.println("메서드 호출");
    }
}
```
```java
// 싱글톤 테스트용 클래스
public class HelloWorld {
    public static void main(String[] args) {
        // Singleton 인스턴스를 두 번 받아옴
        Singleton a = Singleton.INSTANCE;
        Singleton b = Singleton.INSTANCE;

        // 두 인스턴스의 해시코드를 출력 (같은 객체면 해시코드도 같음)
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());

        // 같은 인스턴스인지 비교 (싱글톤이므로 항상 true)
        if (a == b) {
            System.out.println(true); // true 출력됨
        }

        // 싱글톤 인스턴스의 메서드 호출
        a.someMethod(); // "메서드 호출" 출력됨
    }
}
```

객체 초기화 타이밍을 제어하고 싶으면 수동방식으로 구현하고, 그게 아니면 **Enum방식이 간결하고 리플렉션/직렬화 방어가 자동**으로 되어 권장된다.

### mongoose의 싱글톤 패턴
Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 mongoose모듈에서 볼 수 있다.
mongoose의 데이터베이스를 연결할 때 쓰는 conect()라는 함수는 싱글톤 인스턴스를 반환한다.

```javascript
import mongoose from 'mongoose';

// 환경 변수에서 MongoDB 연결 URI를 가져옵니다.
const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error(
    'Please define the MONGODB_URI environment variable inside .env.local'
  );
}

/**
 * 전역(Global) 객체를 사용하여 데이터베이스 연결을 관리합니다.
 * 개발 환경에서는 파일이 변경될 때마다 모듈이 초기화되는데,
 * 이때 연결을 유지하기 위해 global 객체를 활용하는 것이 좋습니다.
 */
let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  // 1. 이미 연결된 경우, 기존 연결을 즉시 반환
  if (cached.conn) {
    console.log('🚀 Using cached database connection');
    return cached.conn;
  }

  // 2. 연결 중인 프로미스가 없으면, 새로 연결 시작
  if (!cached.promise) {
    const opts = {
      bufferCommands: false, // 연결이 끊겼을 때 명령을 버퍼링하지 않음
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongooseInstance) => {
      console.log('✅ New database connection established');
      return mongooseInstance;
    });
  }

  // 3. 진행 중인 연결 프로미스를 기다려서 연결 객체를 저장하고 반환
  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null; // 연결 실패 시 프로미스 제거
    throw e;
  }
  
  return cached.conn;
}

export default dbConnect;
```

### MySQL의 싱클톤 패턴
Node.js에서 MySQL 데이터베이스를 연결할 때도 싱글톤 패턴이 쓰인다.
```javascript
import mysql from 'mysql2/promise';

// 싱글톤으로 관리될 커넥션 풀 객체
let pool;

const getPool = () => {
  // 1. pool이 없으면 새로 생성 (최초 한 번만 실행)
  if (!pool) {
    console.log('✅ Creating new MySQL connection pool...');
    pool = mysql.createPool({
      host: process.env.DB_HOST || 'localhost',
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      waitForConnections: true, // 사용 가능한 커넥션이 없을 때 대기
      connectionLimit: 10,      // 최대 커넥션 수
      queueLimit: 0,            // 대기열 한도 (0은 무제한)
    });
  }

  // 2. 이미 생성된 pool이 있으면 즉시 반환
  return pool;
};

export default getPool;
```

### 싱글톤패턴 단점
TDD(Test Driven Development)를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 어떤 순서로든 실행할 수 있어야 한다.<br>
하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 **독립적인** 인스턴스를 만들기가 어렵다.

## 의존성 주입
모듈 간의 결합을 강하게 만드는 단점이 있다.<br>
이때 의존성 주입(DI, Dependency Injection)을 통해 모듈 간의 결함을 조금 더 느슨하게 만들어 해결 할 수 있다.<br>

